# 线程同步

## 锁

**互斥锁、自旋锁、读写锁（共享锁）、乐观锁、悲观锁**

最底层的两种就是会「互斥锁和自旋锁」，有很多高级的锁都是基于它们实现的，你可以认为它们是各种锁的地基，所以我们必须清楚它俩之间的区别和应用。

加锁的目的就是保证共享资源在任意时间里，只有一个线程访问，这样就可以避免多线程导致共享数据错乱的问题。

当已经有一个线程加锁后，其他线程加锁则就会失败，互斥锁和自旋锁对于加锁失败后的处理方式是不一样的：

    互斥锁加锁失败后，线程会释放 CPU ，给其他线程；
    自旋锁加锁失败后，线程会忙等待，直到它拿到锁；
### 自旋锁

在有些场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。

如果机器有多个CPU核心，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。

为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。

![QQ截图20240719141027](img\QQ截图20240719141027.png)

自旋锁是通过 CPU 提供的 CAS 函数（Compare And Swap），在「用户态」完成加锁和解锁操作，不会主动产生线程上下文切换，所以相比互斥锁来说，会快一些，开销也小一些。

一般加锁的过程，包含两个步骤：

    第一步，查看锁的状态，如果锁是空闲的，则执行第二步；
    第二步，将锁设置为当前线程持有；

CAS 函数就把这两个步骤合并成一条硬件级指令，形成原子指令，这样就保证了这两个步骤是不可分割的，要么一次性执行完两个步骤，要么两个步骤都不执行。

```
class SpinlockExp
{
private:
    VINT32 _dwFlag; // 用于表示锁状态的标志变量

public:
    // 构造函数，初始化标志变量为 0，表示锁未被占用
    SpinlockExp() : _dwFlag(0) {}

    // 锁定函数
    void lock()
    {
        while (1) {
            // 尝试设置标志变量，如果成功则锁定成功，跳出循环
            if (atom_set_mask(&_dwFlag, 0) == true)
                break;
            
            // 如果锁定失败，进入自旋等待
            while (_dwFlag & 1)
                PAUSE(); // 调用 PAUSE 指令，减少 CPU 空转
        }
    }

    // 解锁函数
    void unlock()
    {
        // 清除标志变量，表示锁已释放
        atom_clear_mask(&_dwFlag, 0);
    }

    // 析构函数
    ~SpinlockExp()
    {
        // 在对象销毁时，如果锁仍被占用，进行解锁
        if (_dwFlag & 1)
            unlock();
    }
};

```

#### 问题

当任务线程数多于cpu核数时，忙等不会切换时间片，但又在等待同步，比如8核运行9个线程，效率会下降到1%甚至0.1%



### 互斥锁

互斥锁是一种「独占锁」，比如当线程 A 加锁成功后，此时互斥锁已经被线程 A 独占了，只要线程 A 没有释放手中的锁，线程 B 加锁就会失败，于是就会释放 CPU 让给其他线程，既然线程 B 释放掉了 CPU，自然线程 B 加锁的代码就会被阻塞。

对于互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的。当加锁失败时，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机（通过消息队列或者更优的数据结构）唤醒线程，当这个线程成功获取到锁后，于是就可以继续执行。

所以，互斥锁加锁失败时，会从用户态陷入到内核态，让内核帮我们切换线程，虽然简化了使用锁的难度，但是存在一定的性能开销成本。

那这个开销成本是什么呢？会有两次线程上下文切换的成本：

    当线程加锁失败时，内核会把线程的状态从「运行」状态设置为「睡眠」状态，然后把 CPU 切换给其他线程运行；
    接着，当锁被释放时，之前「睡眠」状态的线程会变为「就绪」状态，然后内核会在合适的时间，把 CPU 切换给该线程运行。

线程的上下文切换的是什么？当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。

上下切换的耗时有大佬统计过，大概在几十纳秒到几微秒之间，如果你锁住的代码执行时间比较短，那可能上下文切换的时间都比你锁住的代码执行时间还要长。



### 读写锁

共享锁具有独占模式和共享模式。读写锁就是共享锁，读写锁中的读锁，在做读操作的时候，是不需要进行阻塞的，读锁是共享的，而写操作是需要阻塞其他线程保证数据安全的，写锁是独占的。

这是一个用自旋锁实现的读写锁。

```
void ReadLock()
{
    // 获取互斥锁以进入临界区
    _lock.lock();
    {
        // 等待直到 _writeRef 的第一个比特位为 0，表示没有写锁
        while(get_mask(&_writeRef, 1)){
            PAUSE(); // 自旋等待
        }
        // 增加读锁引用计数
        atom_increment32(&_readRef);
    }
    // 释放互斥锁
    _lock.unlock();
}

void ReadUnlock()
{
    // 减少读锁引用计数
    atom_decrement32(&_readRef);
}

void WriteLock()
{
    // 获取互斥锁以进入临界区
    _lock.lock();
    // 等待直到所有的读锁都被释放
    while(_readRef > 0) {
        PAUSE(); // 自旋等待
    }
    // 尝试设置写锁标志位，直到成功
    while(atom_set_mask(&_writeRef, 1) == false) {
        PAUSE(); // 自旋等待
    }
    // 释放互斥锁
    _lock.unlock();
}

void WriteUnlock()
{
    // 清除写锁标志位
    bool b = atom_clear_mask(&_writeRef, 1);
    // 确保写锁标志位已成功清除
    ASSERT(b);
}
```













